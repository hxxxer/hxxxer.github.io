[{"categories":"经验","contents":"最后编辑于2024年11月14日\n前言 在搞博客搜索的时候，由于摘要只截了120个字符，导致我想在末尾加个省略号，加完之后又想加一个渐变消失的效果。\n虽然最后也没有加上😂。\n代码展示 下面是文本html：\n\u0026lt;p class=\u0026#34;wraps\u0026#34;\u0026gt;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026lt;/p\u0026gt; 下面是从左到右，渐渐消失的效果：\n.wraps{ -webkit-mask-image: -webkit-linear-gradient(right, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 70%); \u0026lt;!--\tbackground: #fff;--\u0026gt; width: 500px; height: 30px; \u0026lt;!--\tborder: 1px solid red;--\u0026gt; 改成从右到左只需要将上面css代码第二行的right改成left即可。\n代码解释 像background、width、height就纯纯一看便知，而border是指一个框的效果；真正要解释的就第二行。\n-webkit-mask-image是类似于ps的蒙版效果，蒙版上越黑越透明。\n-webkit-linear-gradient是生成一种或多种颜色进行线性过渡的效果的图像，第一个参数是方向，后面的是颜色。以从左到右渐渐消失的为例：\n方向为右，意味着是从右边开始，由第一种颜色向第二种颜色过渡。 rgba的第四个参数是不透明度，默认为1，即不透明。 颜色参数后面那个百分数，意思是从方向上的路径的多少。比如right+30%就是以最左边为起点（0%），向右30%。 根据上面3点，可以得出效果如下图所示： 最后就能得出从左到右逐渐消失的效果。\n其实和PS的蒙版可以说是一样的。\n注意：上面的的70%等表示位置的是以元素的框的大小为标准的（这个框可以在F12里面看），不是以文字的长度为标准的。\n补充 MDN上面的方法是没有-webkit前缀的，暂时不清楚为什么。\n参考 css div怎么渐变到透明\nMDN linear-gradient()\n","permalink":"https://hxxxer.github.io/css%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E6%B8%90%E5%8F%98%E6%B6%88%E5%A4%B1/","tags":["css"],"title":"CSS实现文本渐变消失"},{"categories":null,"contents":"最后编辑于2024年11月12日\n前言 在搞go+fyne移植一个net项目时，不小心把一个检测fyne是否已经配置好的Fyne Setup.exe给提交了，过了几次提交才发现，所以就要删除。\n为了通用性考虑，记录就从寻找大文件开始。\n下面的命令都是在git bash里面执行。\n找出大文件 运行下面的命令列出文件大小的top10：\ngit rev-list --all | xargs -rL1 git ls-tree -r --long | sort -uk3 | sort -rnk4 | head -10 下面的命令也可以，这个是列出全部文件的大小，和上面相反，是升序：\ngit rev-list --objects --all \\ | git cat-file --batch-check=\u0026#39;%(objecttype) %(objectname) %(objectsize) %(rest)\u0026#39; \\ | sed -n \u0026#39;s/^blob //p\u0026#39; \\ | sort --numeric-sort --key=2 \\ | cut -c 1-12,41- \\ | $(command -v gnumfmt || echo numfmt) --field=2 --to=iec-i --suffix=B --padding=7 --round=nearest 移除commit中文件的引用 该命令仅仅只是移除commit中对某文件的引用,如果某次commit同时提交了要删除的文件和要保留的文件，该命令只会移除要删除文件的引用，并不会移除要保留的文件和当次commit记录，所以无需担心会把不该删除的文件删掉了。\ngit filter-branch --force --prune-empty --index-filter \u0026#39;git rm -rf --cached --ignore-unmatch 文件路径/文件名\u0026#39; --tag-name-filter cat -- --all 我在这一步怎么都删除不了，应该是因为我的文件名带空格，不过考虑到exe文件就这一个，我就用*.exe代替了。\n删除指向旧提交的指针 rm -rf .git/refs/original/ 让历史记录全部过期 设置所有未关联对象过期时间为现在，默认为90天。\n目的是放弃所有未关联对象恢复的可能性，因为reflog 是找寻它们踪迹的最后途径了。\ngit reflog expire --expire=now --all 重新打包并删除垃圾文件 git repack -A -d git gc --aggressive --prune=now 强制推送到远程 git push --force --all 最后 如果这个项目有其他人，那大家都要在强制推送之后clone一下，防止又把垃圾文件push上去。\n参考 git项目大小优化笔记,删除历史提交中的大文件 彻底删除git中的较大文件（包括历史提交记录）\n","permalink":"https://hxxxer.github.io/git%E5%BD%BB%E5%BA%95%E5%88%A0%E9%99%A4%E5%8E%86%E5%8F%B2%E4%B8%AD%E7%9A%84%E5%A4%A7%E6%96%87%E4%BB%B6/","tags":[],"title":"Git彻底删除历史中的大文件"},{"categories":"经验","contents":"最后编辑于2024年11月11日\n前言 之前需要调用dll里面的图标，而调用的函数用的是一个dll的内部的函数，所以这里记录一下调用的两种方法。\nVS的项目引用 在VS的方案资源管理器里面（Ctrl+Alt+L），右键依赖项 - 添加项目引用，然后选择dll文件，例如AddDll.dll（里面有一个ADD类，ADD里面有一个calculate公共方法）。\n之后就可以在依赖项 - 程序集里面看到Add了。\n调用也很简单：\nusing AddDll; AddDll.ADD add = new(); int c = add.calculate(a,b); 使用DllImport 在需要引用的函数的上一行添加[DllImport(\u0026quot;user.dll\u0026quot;, ......)]就行，下面是我调用的获取dll图标函数：\n[DllImport(\u0026#34;shell32.dll\u0026#34;, CharSet = CharSet.Auto)] private static extern IntPtr ExtractIcon(IntPtr hInst, string lpszExeFileName, int nIconIndex); 后面那个CharSet = CharSet.Auto是调用字符集，Auto是自动选择合适的。\n下面函数的定义记得加static extern，以表示这个是一个外部方法实现，它将在运行时解析到指定的非托管代码。\n这个方法需要知道dll内部的函数及其形参。\n补充其它的DllImportAttribute属性 EntryPoint=\u0026quot;MessageBoxA\u0026quot;，这个可以也指定函数，这样下面的函数引用就可以用别的名字，但是注意这个EntryPoint赋值和下面的函数引用不一定相同，比如上面的ExtractIcon，在EntryPoint里面应该是ExtractIconW。 ExactSpelling 指示 EntryPoint 是否必须与指示的入口点的拼写完全匹配，如：ExactSpelling=false； PreserveSig指示方法的签名应当被保留还是被转换， 如：PreserveSig=true； SetLastError 指示方法是否保留 Win32\u0026quot;上一错误\u0026quot;，如：SetLastError=true； CallingConvention指示入口点的调用约定， 如：CallingConvention=CallingConvention.Winapi； 参考 C#调用DLL的几种方法\n【C#】DllImport的使用\nVS2022 C#编写DLL和调用外部DLL中的方法\n","permalink":"https://hxxxer.github.io/c%23%E8%B0%83%E7%94%A8dll%E7%9A%84%E6%96%B9%E6%B3%95/","tags":["C#","dll"],"title":"C#调用DLL的方法"},{"categories":"经验","contents":"最后编辑于2024年11月11日\n前言 在GitHub actions自动发布的时候，需要使用zip命令来压缩发布文件，但是会连带很多上级目录一起压缩，需要去除这些目录。\n操作 原来的命令是这样的：\nzip -r ShortcutVisualizer.zip ./ShortcutVisualizer/bin/Release/net6.0-windows/win-x64/publish 这样在压缩出来的时候就会带上ShortcutVisualizer/bin/Release/net6.0-windows/win-x64/publish/这些无关的文件夹。\n想要去除只需要将-r更改为-rj。\n补充 使用tar命令压缩的话，只需要在末尾使用-C指定文件所在目录就行，其本质是切换工作目录，来达到工作目录之前的文件夹不压缩的目的。\n参考 Linux下压缩不包含路径信息的压缩包\nShell创建zip文件不包含完整路径方法\n","permalink":"https://hxxxer.github.io/linux%E5%8E%8B%E7%BC%A9%E4%B8%8D%E5%8C%85%E5%90%AB%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%91%BD%E4%BB%A4/","tags":["压缩","Linux"],"title":"Linux压缩不包含绝对路径命令"},{"categories":"课程学习","contents":"最后编辑于2024年11月10日\n前言 嵌入式的第四次实验是编译一个虚拟字符驱动模块，我在学校电脑上可以编译成适合x86架构的版本，但是编译成开发板上的arm架构的就不行。\n后来在自己的电脑上尝试了一下，在一些参考资料的帮助下，最终完成既定目标。现在记录一下。\n虚拟机平台VBox，Ubuntu22.04。\n配置编译环境 将资料里面的开发板linux源码\\FriendlyARM-2440-DVD\\Linux\\linux-2.6.32.2-mini2440-20150709.tgz解压到虚拟机。\n然后在解压目录下，将mini2440_config_t35复制为.config：\ncp mini2440_config_t35 .config 然后执行下面的命令：\nmake oldconfig \u0026amp;\u0026amp; make prepare LCD就选择6. 3.5 inch 240X230 Toppoly LCD (FB_S3C2410_T240320)。\n执行过程中如果出现有关arm-linux-gcc的报错，就去检测一下arm-linux-gcc -v有没有输出，没有就配置一下。\n执行完成之后，再输入以下命令（这里有些报错是没问题的，只要都是warning就行）：\nmake scripts 执行完成就配置好了编译环境。\n解释 mini2440_config_t35就是适合开发板屏幕的那个config文件，其实里面的mini2440_config_文件内容都相差不大，只有屏幕相关部分有差别。\n将其复制为.config文件是为了设置内核配置信息，确保编译环境与开发板的实际情况相匹配。（其实这段话我是问AI的，我也不是很懂）\nmake oldconfig是为了查看是否有新的配置信息要处理，这里感觉没有什么用，但是网上都做了这个😋。\nmake prepare是为了准备之后编译要用到的文件和符号链接，以及处理一些依赖关系，以确保所需的工具和资源都已准备好。\nmake scripts是为了编译一些之后编译要用到的脚本文件。\n更改驱动源码 原来的源码chrdevbase.c有些问题，头文件的引用并不对，需要改成下面的：\n#include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/uaccess.h\u0026gt; 这里的引用我是复制老师发的那篇CSDN博客的。\n更改makefile.txt 这个文件内容也有些问题，改成下面的就行：\nKERNELDIR := /home/hx/linux/mini2440-lib/linux-2.6.32.2 ENV:=ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- obj-m := chrdevbase.o all: $(MAKE) $(ENV) -C $(KERNELDIR) M=$(shell pwd) modules clean: $(MAKE) $(ENV) -C $(KERNELDIR) M=$(shell pwd) clean 而且文件名也要改成Makefile，注意一定要大写M开头。\n补充 后来发现上面的更改的添加的ENV不是必要的，这个只是用在编译的gcc版本和开发板的不对的时候用的，具体可以看这里。\n编译及测试 在驱动源码目录下执行make即可，如果前面没有问题，那就可以看到chrdevbase.ko了。\n后续的驱动测试就按参考一进行。\n参考 嵌入式linux驱动开发-字符设备驱动\n加载驱动模块的两种方法\nlinux make modules 命令详解\nLinux驱动——编译驱动的两种形式（内核目录外、内核目录中）\nLinux驱动安装遇到的问题（Kernel configuration is invalid）（Invalid module format）\n驱动编译错误 /bin/sh: scripts/mod/modpost\n编译内核驱动模块出错（error: asm/xxx: No such file or directory）\nLinux模块文件如何编译到内核和独立编译成模块？\n","permalink":"https://hxxxer.github.io/%E7%BC%96%E8%AF%91mini2440%E7%9A%84%E8%99%9A%E6%8B%9F%E5%AD%97%E7%AC%A6%E9%A9%B1%E5%8A%A8/","tags":["mini2440","驱动","编译"],"title":"编译mini2440的虚拟字符驱动"},{"categories":"经验","contents":"最后编辑于2024年11月09日\n前言 在搞那个快捷方式可视化的net程序时，因为图标列表第一个是百度网盘的图标，而文件夹没有指定图标，就默认第一个。结果就是一堆百度网盘😅。\n就算指定文件夹节点的图标索引为-1也还是这样，不知道为什么，所以就要搞一个文件夹图标。\n代码 主要是通过shell32 API的ExtractIcon函数来提取，然后文件夹图标的索引在shell32.dll里面是3。代码如下\npublic class ShellIcon { [DllImport(\u0026#34;shell32.dll\u0026#34;, CharSet = CharSet.Auto)] private static extern IntPtr ExtractIcon(IntPtr hInst, string lpszExeFileName, int nIconIndex); public static Icon? GetFolderIcon(int index) { // 从shell32.dll提取文件夹图标 (索引3是标准的关闭文件夹图标) IntPtr hIcon = ExtractIcon(IntPtr.Zero, \u0026#34;shell32.dll\u0026#34;, index); if (hIcon != IntPtr.Zero) { return Icon.FromHandle(hIcon); } return null; } } ....... // 添加文件夹图标 Icon folderIcon = ShellIcon.GetFolderIcon(3); if (folderIcon != null) { imageList1.Images.Add(\u0026#34;folder\u0026#34;, folderIcon); } 参考 Claude又是AI😋\n","permalink":"https://hxxxer.github.io/net%E8%8E%B7%E5%8F%96dll%E4%B8%AD%E7%9A%84%E5%9B%BE%E6%A0%87/","tags":["C#","dll","图标"],"title":"C#获取dll中的图标"},{"categories":"经验","contents":"最后编辑于2024年11月09日\n前言 早就知道GitHub actions很方便好用，所以我想搞一个。不过遇到了好多困难，现在基本搞定了，记录一下。\n主要的难点是yml文件的编写，毕竟是第一次接触，脑子有点混。\n新建工作流 就直接在actions里面新建就行，GitHub有net desktop模板。\nyml文件的理解 开头的on是指当发生什么的时候开始这条工作流，比如：\non: push: tags: - v* 就是在push且tag是以v开头时启动。注意push内的每个条件是或关系，只要满足一个就开始工作。\n然后就是具体工作内容，是一种多级列表，每一级都可以有多个。\n其实工作流程就是大概按顺序运行steps，这里大概是：\n启动系统 拉取仓库 安装net core net项目初始化依赖 构建release版本 压缩成zip 发布到release 感觉就像自动执行指令。\nsteps属性理解 最末级就是steps，里面的属性有：\nname，就是名字。 id，非必要，其它地方引用时候用。 uses，可以选择GitHub上现有的操作，比如获取仓库内容、安装net vore。 with，一般是使用uses时配置具体的参数，比如安装net core时指定版本。 run，就是执行指令，不同平台（win，Ubuntu）使用的不同 env，一些变量，通过$env:\u0026lt;名字\u0026gt;，来引用。（好像在一些字符串里面不能被正确解析），比如： run: | $zipFilePath = \u0026#34;${{ github.workspace }}\\$env:\u0026#34; 发布到release 这边是重点，我是先搞了一个给这个action用的token，然后再在yml文件里面设定steps。\nTOKEN 新建TOKEN 在头像 - setting - 侧边栏的Developer Settings - 侧边栏的Personal accesskey tokens - Token (classic)。然后generate new token - Generate new token (classic)。然后输密码之后，来到新建token的页面，名字随便起，过期时间随便，下面是Select scopes选择前三个。 ** 新建完成之后记得复制token，因为只会出现一次，后面要用。\n新建secrets 刚刚的token要保存到项目的secrets里面。secrets是一种可以在yml里面调用的变量，但是无法得知内容。\n打开项目的setting - 侧边栏的Secrets and variables - Actions。然后选择绿色的New repository secret。接下来就是新建页面，名字随便，记住就行，secret就填刚刚的token。然后保存就行。\n但是还没完，还要配置项目的权限。打开项目的setting - 侧边栏的Actions - General，找到Workflow permission，选择第一个Read and write permissions。到这里就完成了。\n补充 后来发现不用新建，直接在发布的with: token里用${{ secrets.GITHUB_TOKEN }}就行😂。\n在yml文件设定发布 这里我是使用别人的actions和网友的模板：\n- name: Create and Upload Release uses: softprops/action-gh-release@v2 if: startsWith(github.ref, \u0026#39;refs/tags/\u0026#39;) with: token: ${{ secrets.PB_TOKEN }} tag_name: ${{ github.ref_name }} name: Release ${{ github.ref_name }} body: 船新版本！ makelatest: true draft: false prerelease: false files: | HugoHelper.zip github.ref_name就是上传连接的名字，比如我是限制在tags前缀是v时启动工作流，那这里就是v\u0026hellip;。\nname和tag_name顾名思义，name就是这次发布的名字，tag_name就是发布的tag的名字。\nmakelatest就是让这次发布设置为项目的最新release。\n参考 Github Actions自动发布release\n学会Github Actions自动发布版本\nGitHub Action 自动构建 并release\nGitHub Actions - 使用 tag 作为发布的版本号\n.NET Core项目提示找不到project.assets.json文件\n","permalink":"https://hxxxer.github.io/net%E4%BD%BF%E7%94%A8github-actions/","tags":["NET","actions","自动化"],"title":"NET使用Github Actions"},{"categories":"经验","contents":"最后编辑于2024年11月08日\n前言 我在GitHub启用了actions，其工作是检测到上传的tags是v开头时，自动构建并发布。但是刚开始不会在vs里面搞。现在搞明白了，记录一下。\n打标签 打开位于vs顶栏的git - 管理分支，然后对某一个上传记录右键 - 新建标签。新建完成之后，打开顶栏的视图 - git更改，然后在git更改窗口的分支那一栏，打开右边的选项（三个点） - 将所有标签推送到 - origin。\n参考 Visual Studio 2022 Git Push Tags\n","permalink":"https://hxxxer.github.io/vs%E6%8E%A8%E9%80%81tags/","tags":["VS","推送"],"title":"VS推送tags"},{"categories":"经验","contents":"最后编辑于2024年11月06日\n前言 在搞VBox的共享文件夹的时候，怎么搞都不能在开机的时候自动挂载，包括安装增强功能，指定目录开启自动挂载，这些都不行。最后直接祭出杀器，新建一个开机服务。\n法一：使用/etc/rc.local 因为这个方法是很传统的方法，在新版本的Ubuntu已经不推荐了，但是可能用得上，记录一下。\n打开或新建/etc/rc.local文件。\n在文件中添加挂载命令：\n#!/bin/bash /bin/mount -t vboxsf shared /home/hx/Desktop/shared exit 0 给予+x权限。\n法二：使用服务单元文件（推荐） 这个方法在新版Ubuntu中更为推荐，因为可操纵性更强。\n新建/etc/systemd/system/vbox-mount.service。\n写入以下内容：\n[Unit]\rDescription=vbox mount shared\rAfter=network.target\r[Service]\rType=oneshot\rRemainAfterExit=yes\rExecStart=/bin/mount -t vboxsf shared /home/hx/Desktop/shared\rUser=root\r[Install]\rWantedBy=multi-user.target 然后重新加载配置文件：\nsudo systemctl daemon-reload 然后启动服务单元：\nsudo systemctl enable vbox-mount.service 可以查看一下启动状态：\nsudo systemctl status vbox-mount.service 内容解释 After=network.target，就是在网路服务之后再执行，注意不是强制性的。 Type=oneshot，只执行一次。 RemainAfterExit=yes，执行退出之后仍然认为服务活跃，这是为了依赖这项服务的服务能正常运行（虽然这里没有）。 WantedBy=multi-user.target，在多用户模式下启动？猜测是在开机选用户那里启动。 法三：使用init.d脚本 这个和法一一样不常用了，但我是松鼠😋！\n创建启动脚本/etc/init.d/myscript。\n在文件中添加挂载命令：\n#!/bin/bash /bin/mount -t vboxsf shared /home/hx/Desktop/shared exit 0 给予+x权限。\n注册脚本到启动序列：\nsudo update-rc.d myscript defaults 法四：使用profile文件 就像将arm-linux-gcc及其库添加到环境变量一样，直接添加命令到~/.profile或者~/.bashrc即可\n参考 全是AI写的😋\n","permalink":"https://hxxxer.github.io/linux%E6%96%B0%E5%BB%BA%E5%BC%80%E6%9C%BA%E6%9C%8D%E5%8A%A1/","tags":["Ubuntu","开机服务"],"title":"Ubuntu新建开机服务"},{"categories":"经验","contents":"最后编辑于2024年11月05日\n前言 这篇博客就是记录一些提醒自己（包括未来的自己😋）的tips\n控件改(Name)，事件重新绑定 如上。以按钮为例，新建了一个button1，然后还没改名，不小心双击了，结果就直接新建Click事件了，这时候再改名的话，form1.cs里面Click事件还是button1_Click。\n结论就是直接改成改名之后的事件名，这时候设计器肯定变成空白了，然后打开随便一个控件或者窗口，什么都行，的属性页，然后选到改动的那个按钮，更改Click事件的绑定函数就行。\n如果设计器还是空白，那就关闭设计器，再打开，根据设计器的报错去设计文件里面更改事件绑定的函数就行。\n参考\n","permalink":"https://hxxxer.github.io/20241105net%E7%A8%8B%E5%BA%8F/","tags":["NET","VS"],"title":"VS NET开发桌面程序的一些小经验"},{"categories":"课程学习","contents":"最后编辑于2024年11月05日\n前言 c语言编写的代码需要编译才能运行，在电脑的amd64架构就是使用gcc来编译。如果想要编译成板子能运行的文件，就需要适配板子的arm架构的编译工具，也就是arm-linux-gcc，因为和电脑的不同，也叫做交叉编译。\n下面就是我的交叉编译环境的搭建。（因为这篇Blog是在我搭建完成之后写的，可能会有所错漏，文章的尾部添加了评论功能，不过要登录Github）\n我的环境配置 win11 64位，21H2，专业版 虚拟机平台为Oracle VM VirtualBox（VBox），安装映像为Ubuntu 22.04.5 配置前准备 交叉编译工具 就资料里面那个arm-linux-gcc-4.4.3.tar.gz，路径是\\FriendlyARM-2440-DVD\\Linux\\arm-linux-gcc-4.4.3.tar.gz。\n虚拟机配置 虚拟机平台可以选择VMware，也可以和我一样。系统就Ubuntu，版本选择LTS版的20、22、24应该都可以。\n打开虚拟机，先确保你可以获取root权限。摁Ctrl+Alt+T打开终端，输入su，然后输入密码（看不到但确实在输入），可能是你的开机密码。如果不是，可以百度（你的虚拟机平台）root账户，之类的。因为有的虚拟机平台会新建一个root账户，我的就是。\n开始搭建环境 以下内容均参考一篇CDSN博客1，命令均在root权限下执行。\n解压文件 首先通过共享文件夹或者拖文件等方法，将arm-linux-gcc-4.4.3.tar.gz复制到虚拟机内，并在当前文件夹打开终端，执行解压指令。\nsudo tar xvzf arm-linux-gcc-4.4.3.tar.gz -C/ 执行完成之后会将压缩文件解压到/opt/内，可以使用cd和ls命令去看一下。下面是文件夹树, 我们主要需要的就是文件夹4.4.3。\n|opt\r|-- FriendlyARM\r| `-- toolschain\r| `-- 4.4.3\r|....... 复制交叉编译工具到arm 然后在/usr/local/下新建一个文件夹arm，并给权限。\nsudo mkdir /usr/local/arm sudo chmod 777 /usr/local/arm 然后将文件夹4.4.3复制到arm文件夹。\ncd /opt/FriendlyARM/toolschain/ sudo cp -r 4.4.3 /usr/local/arm 配置环境变量 环境变量是写在/etc/profile里面，所以下面的操作可以在终端执行，也可以用文本编辑器。\n终端命令：\nsudo nano /etc/profile 然后在文件尾部添加两行：\nexport PATH=$PATH:/usr/local/arm/4.4.3/bin export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/arm/4.4.3/lib 添加完之后，使用source命令重新加载配置文件：\nsource /etc/profile 执行完后终端不会有什么输出，以防万一可以重启。\n安装缺失的库 在执行完上面的操作之后，理论上arm-linux-gcc就安装完成了，但是事实上还没完，因为这个交叉编译工具非常老，是为32位系统做的，而现在的系统基本都是64位，所以需要补装一些32位的库。\n由于我的虚拟机已经安装好了，所以无法复现，但是可以根据报错来安装缺失的32位库。先在终端输入命令检测版本，如果没有库是缺失的话，是可以正常输出的。\narm-linux-gcc -v 如果没有安装好32位的库，就会报错（下面不是原始的报错，是我网上找到报错信息的重点，但格式相差不大）：\nerror while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory 重点是libstdc++.so.6，根据这个来安装合适的32位版本的库，以防万一，64位也一起安装（其实一般64位版本是预安装的）：\nsudo apt-get install libstdc++6 sudo apt-get install lib32stdc++6 可以看到32位就是在lib后面加32。\n如果安装失败，可以拿报错去百度搜一下。\n接下来就是不断重复arm-linux-gcc -v、看报错、sudo apt-get install lib...、sudo apt-get install lib32...，直至看到正常输出了。\n参考 【嵌入式】Linux开发工具arm-linux-gcc安装及使用\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://hxxxer.github.io/20241105022715/","tags":["mini2440","环境搭建"],"title":"mini2440的交叉编译环境搭建"},{"categories":"折腾","contents":"最后编辑于2024年11月07日\n前言 因为使用hugo时，有几个很常用的指令，比如hugo server之类的，但是去文件夹、然后打开ps7、再执行命令，这套流程实在是太麻烦了，所以我就想搞一个exe，把常用的功能都搞进去。\n项目地址HugoHelper\n常用命令 这段其实是为了防止我忘了而写了😋。\n# 切环境 Set-Location -Path \u0026#34;D:\\Tools\\hugot\\BST\u0026#34; # 生成可以上传到github的网页文件 hugo --contentDir \u0026#34;C:\\Users\\15641\\Documents\\Blog\u0026#34; # 运行本地测试服务 hugo server --port 6138 --contentDir \u0026#34;C:\\Users\\15641\\Documents\\Blog\u0026#34; # 创建新博客 hugo new content ($fileName + \u0026#34;.md\u0026#34;) --contentDir \u0026#34;C:\\Users\\15641\\Documents\\Blog\u0026#34; # 清理垃圾 hugo --cleanDestinationDir --contentDir \u0026#34;C:\\Users\\15641\\Documents\\Blog\u0026#34; 注意！\n刚运行玩本地服务不能马上git add .，因为此时那些html的指向还是localhost😓，这时候上传就搞笑了。要hugo一下才行。\n开发进程 配置VS开发环境 其实直接在选择新项目里面就有可以添加新环境的地方，安装就行。\n安装之后，新建一个.NET项目，然后就会看到一个设计用的窗口，这时候摁Ctrl+Alt+X打开工具箱，拖一个Botton出来。\n右键按钮 - 属性，可以修改(Name)，这个(Name)是程序用的，好像只能字母数字。而后面那个Text才是我看到的按钮文本。\n窗口的属性里面还能更改图标，就在那个Icon里面选一个ico文件就行。\n“创建新Blog”按钮 基本思路就是新开一个ps7进程，然后输入指令，或者在启动的时候用-Command来实现带命令启动。\n我一开始就是直接将ps1脚本里面的内容搬到代码里，脚本内容是通过--fileName来实现文件名的传递，但是如果直接照搬到-Command之后，无论我怎么搞都不能实现正常的文件名传递。\n然后我就用直接执行脚本 + 传递参数的方式，执行很完美，但是感觉代码太WET😅，放弃。\n最后我就是通过新开一个无窗口ps7进程，重定向输入输出，然后通过streamWriter.WriteLine，一行行地输入到ps7\n最新的是新开了一个创建blog窗口，这样就可以自由输入文件名了，原来是硬编码以当前时间为文件名。\n一些简单的按钮 就是一些在点击事件内就能完全执行的按钮，包括开启Server、构建网页、清理垃圾。\n开启Server我想看到ps窗口，就简单设定了一下ps进程设定：\nRedirectStandardInput = true, // 重定向标准输入 RedirectStandardOutput = false, // 重定向标准输出 UseShellExecute = false, // 不使用系统外壳程序启动 CreateNoWindow = false // 创建窗口 Git窗口 我是想将Git操作也写在窗口里，但是目前还没搞定。\n手动 目前搞定了手动git，设置ps进程信息为进入public目录，并添加NoExit参数就行。\nstring script = $\u0026#34;Set-Location {AppConfig.HugoRootDir};cd public\u0026#34;; ......... FileName = \u0026#34;C:\\\\Program Files\\\\PowerShell\\\\7\\\\pwsh.exe\u0026#34;, Arguments = $\u0026#34;-NoExit -Command {script}\u0026#34;, RedirectStandardOutput = false, // 重定向标准输出 UseShellExecute = false, // 不使用系统外壳程序启动 CreateNoWindow = false // 不创建窗口 自动 这个就确实没搞定。\n11月7 添加配置文件 右键项目 - 添加 - 新建项，找到应用程序配置文件就行。在里面添加键值对就行，通过在代码使用ConfigurationManager.AppSettings[\u0026quot;键\u0026quot;]来获取对应的值。\n我现在是把配置的初始化写在专门一个类里面AppConfig.cs，只要其它的类的命名开机和它一样（都是namespace Hugo），就可以通过AppConfig.HugoRootDir直接调用。\n窗口虚化 因为按钮的点击事件都是通过ps间接实现的，所以有的耗时，为了提醒我正在运行而不是没响应之类的。\n现在是直接将窗口的透明度临时设置为0.91，结束再改回来。不过我想实现类似高斯模糊的效果，但是好像都要引入包。\n参（帮）考（手） 通义千问\n","permalink":"https://hxxxer.github.io/20241105015218/","tags":["NET","Hugo"],"title":"使用.NET开发hugo小程序"},{"categories":"经验","contents":"最后编辑于2024年11月05日\n前言 在编用于hugo的.NET桌面程序时，需要在启动服务时，禁用更新静态网页文件，在问千问时，它使用了异步编程：将开启服务函数定义为异步，并在await Task.Run(() =\u0026gt; process.WaitForExit());后，otherBotton_Click = true;。一下子唤起了我了解异步编程的兴趣。\n其实我之前已经多次了解甚至使用过了，但是还是不能说是学会，现在凭借AI的力量，简单地记录一下学习过程。\nAI和我的问答 问答一 有关异步编程，我可以这么理解吗\n一个异步函数执行时是独立于主程序之外，其执行时不影响主程序，把异步函数和主程序看成两条独立的执行线，在它们内部，异步函数和主程序仍然是同步阻塞的\n你的理解大体上是正确的，但需要进一步澄清一些细节，以便更准确地理解异步编程的概念。\n异步编程的基本概念 非阻塞性：异步操作的一个主要特点是它们不会阻塞主线程。这意味着当一个异步任务启动后，程序不会等待这个任务完成，而是继续执行后续的代码。一旦异步任务完成，通常会通过回调函数、事件、或者Future/Promise等机制通知主线程。\n并发与并行：\n并发（Concurrency）是指多个任务可以交替执行，即使在单核CPU上也可以通过快速切换上下文来实现。 并行（Parallelism）是指多个任务可以同时执行，这通常需要多核CPU的支持。 执行模型：在异步编程中，虽然异步任务看起来像是独立运行的，但实际上它们可能是在同一个线程中通过事件循环（Event Loop）来管理的。例如，在JavaScript的Node.js环境中，大多数I/O操作都是异步的，并且是非阻塞的，这是因为它们利用了底层的操作系统特性来处理I/O请求，而不需要阻塞主线程。\n你的理解中的几点说明 独立于主程序：异步函数确实可以在一定程度上独立于主程序执行，但这并不意味着它们完全独立。实际上，异步函数的执行通常依赖于事件循环或者其他调度机制。这意味着异步任务的执行时机是由系统决定的，而不是立即执行。\n不影响主程序：正确。异步函数执行时，主程序可以继续执行其他任务，不会因为等待异步任务完成而阻塞。\n两条独立的执行线：这个说法有些误导。虽然从逻辑上看，异步函数和主程序似乎是两条独立的执行线，但在实际实现中，它们可能共享同一个线程。例如，在Node.js中，所有的异步I/O操作都是在同一个线程上通过事件循环来管理的。\n内部仍然是同步阻塞的：这一点需要具体情境来看。在异步函数内部，如果它执行的是纯计算任务（例如复杂的数学运算），那么这部分确实是同步阻塞的。但如果异步函数涉及I/O操作或其他耗时任务，这些操作本身通常是通过操作系统或其他库异步处理的，因此不会阻塞异步函数的执行。\n示例 假设你有一个异步函数来读取文件：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;future\u0026gt; std::future\u0026lt;std::string\u0026gt; readFileAsync(const std::string\u0026amp; filename) { return std::async(std::launch::async, [filename] { std::ifstream file(filename); std::string content((std::istreambuf_iterator\u0026lt;char\u0026gt;(file)), (std::istreambuf_iterator\u0026lt;char\u0026gt;())); return content; }); } int main() { auto future = readFileAsync(\u0026#34;example.txt\u0026#34;); // 主程序继续执行其他任务 std::cout \u0026lt;\u0026lt; \u0026#34;Doing other work...\u0026#34; \u0026lt;\u0026lt; std::endl; // 等待异步任务完成 std::string content = future.get(); std::cout \u0026lt;\u0026lt; \u0026#34;File content: \u0026#34; \u0026lt;\u0026lt; content \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中，readFileAsync 是一个异步函数，它使用 std::async 来启动一个新线程读取文件。主程序在启动异步任务后继续执行其他任务，直到需要文件内容时才调用 future.get() 阻塞等待结果。\n问答二 那我这样理解可不可以\n异步函数在主程序之外执行，当主程序需要结果的时候就调用await之类的，调用时异步函数可以看成其回到主程序的执行线上，可能会阻塞主程序。\n你的理解基本是正确的，但有一些细节需要注意。让我们进一步澄清一下：\n异步函数的执行 异步函数在主程序之外执行：\n部分正确：异步函数确实可以在主程序之外执行，但这取决于具体的实现方式。在某些情况下，异步函数可能在另一个线程或进程中执行（例如使用 std::async 或多线程库）。而在其他情况下，异步函数可能在同一线程内通过事件循环（例如在Node.js中）执行。 当主程序需要结果的时候就调用 await 之类的：\n正确：当你在主程序中使用 await 关键字（或类似的机制，如 std::future::get）来获取异步函数的结果时，主程序会暂停执行，等待异步任务完成。这是为了确保你可以在主程序中安全地使用异步任务的结果。 调用时异步函数可以看成其回到主程序的执行线上，可能会阻塞主程序：\n部分正确：当你使用 await 或类似的方法获取异步任务的结果时，主程序确实会暂停执行，等待异步任务完成。这种暂停可以被视为一种“阻塞”，但这种阻塞是局部的，仅限于当前的同步上下文。在异步任务完成之前，主程序的其他部分仍然可以继续执行其他任务。 详细解释 异步任务的执行：\n多线程：如果异步任务在另一个线程中执行（例如使用 std::async），那么它确实是独立于主程序的线程。主程序可以在等待结果时继续执行其他任务。 事件循环：如果异步任务在同一个线程中通过事件循环执行（例如在Node.js中），那么它会在事件循环的控制下异步执行。主程序可以在等待结果时继续处理其他事件。 获取结果：\nawait 关键字：在支持 await 的语言（如C#、JavaScript）中，await 会暂停当前的同步上下文，等待异步任务完成。在这期间，主程序的其他部分仍然可以继续执行其他任务。 std::future::get 方法：在C++中，std::future::get 会阻塞当前线程，直到异步任务完成。这意味着当前线程会暂停，但其他线程仍然可以继续执行。 示例 假设我们使用C++的 std::async 和 std::future 来实现一个异步任务：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; int asyncTask() { std::this_thread::sleep_for(std::chrono::seconds(2)); // 模拟耗时操作 return 42; } int main() { std::future\u0026lt;int\u0026gt; result = std::async(std::launch::async, asyncTask); // 主程序继续执行其他任务 std::cout \u0026lt;\u0026lt; \u0026#34;Doing other work...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;Still doing other work...\u0026#34; \u0026lt;\u0026lt; std::endl; // 获取异步任务的结果，可能会阻塞主程序 int value = result.get(); std::cout \u0026lt;\u0026lt; \u0026#34;Async task result: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; return 0; } 在这个例子中：\nasyncTask 是一个异步任务，它在另一个线程中执行。 主程序在启动异步任务后继续执行其他任务。 当主程序调用 result.get() 时，它会阻塞当前线程，等待异步任务完成。 总结 异步函数可以在主程序之外执行，具体取决于实现方式。 当主程序需要结果时，可以使用 await 或类似的方法来获取结果，这会暂时阻塞当前的同步上下文。 在等待结果期间，主程序的其他部分仍然可以继续执行其他任务。 最后我的理解 其实关于异步编程在很多情况都不需要了解底层原理，只需要知道怎么用就行，所以我觉得用执行线来理解也是可以的。\n主程序是一条主线，调用了一个异步函数就相当于新开了一条执行线，可能是并行（多进程），也可能是并发（不停切换），直到await之类的之前，异步执行线和主程序各自运行。等到主程序，或者其它执行线叫了异步执行线，那么这个异步执行线就加入到叫它的执行线上，阻塞这个执行线，直到有结果了。\n下面是一张感觉有的点合适的网图：\n","permalink":"https://hxxxer.github.io/20241105001824/","tags":["异步"],"title":"异步编程的一些理解"},{"categories":"折腾","contents":"编辑于2024年11月03日\n前言 因为感觉自己需要一个平台来记录一些技术博客，所以寻找了一些开源博客平台，一开始选择的是suiyan，因为其生成的html排版和vscode、marktext的预览都不同，只能放弃。suiyan项目地址\n然后看到了使用hugo的blowfish主题的一篇博客，感觉很不错，就开始用hugo，但奈何这个主题我一直调不出来，😂😂，又放弃了。不过这次我又找到了hugo上面的diary主题，这次一路磕磕碰碰，勉强搞定了，所以记录一下。\n使用suiyan（已放弃） suiyan项目是在公众号看到的，直接git clone下来，然后运行python -m venv env来创建虚拟环境（甚至这时候创建虚拟环境已经忘了，还是去百度的），然后就是熟悉的pip install -r requirment.txt，接着运行w.py即可。甚至还有窗口GUI，感觉对我这种新手很良好。\n本来体验挺不错的，但是它的md格式解析好像和vscode、marktext不一样，多级列表没有正确解析成html。这我就没办法了，只能放弃。（也许会去仓库提一下issue？）\n使用hugo 尝试blowfish（又放弃了😂） 这个是我直接搜github blog，搜出来一篇介绍hugo+github pages的博客就是参考的第一个链接。其实这个博客的主题风格我感觉挺喜欢的，所以马上入坑了。\n然后我就安装了Hugo，其实只要去winget安装就行，注意要安装extended（扩展版），因为扩展版才支持modules，而这个主题是需要modules的。\n但是我按照上面那篇博客进行搭建，却不能正常运行，跑不起来。然后我就去看了主题的toml，发现它支持的最高hugo版本是0.135.0，但是我安装的是最新版0.136.5。于是我就卸载最新版，（不知道为什么，执行winget uninstall --id Hugo.Hugo.Extended不行，要执行winget uninstall --name \u0026quot;Hugo(扩展版)\u0026quot;），安装0.135.0版本。\n结果还是不行，所以懒得折腾了，放弃😂。\n接触并使用diary 这个则是我随意逛hugo的主题展览页时挑中的其中一个，只有它符合：\n有目录 风格简洁淡雅 其它的都不太符合我的要求，所以我就相中它了，下面是我的搭建过程：\n搭建过程 先在一个目录下新建一个hugo站点：\nhugo new site BlogSite 然后通过git拉主题文件下来：\ngit submodule add https://github.com/AmazingRise/hugo-theme-diary.git themes/diary 等下载完之后，就将主题里面一些文件夹拷贝到hugo的站点下：\n/exampleSite/*\r/archetypes 然后将站点根目录的hugo.toml删除，复制出来的那个config.toml改名hugo.toml。\n此时就可以在当前目录运行本地服务测试命令：\nhugo server 没问题就完成这一部分了。\n修一些bug 那个新的hugo.toml里面有个bug，我当时排除了半天😓。文件尾部的定义侧边栏的命名漏了一个字母，导致和模板文件对不上。\nbug就是下面的[[menus.main]]，改之前是[[menu.main]]，模板文件里是site.Munus.main😓。也许我会去提一下issue😋\n而且我一开始是不知道要把config.toml改名hugo.toml，因为只有hugo.toml才支持定义列表，可能是config.toml太老版本了吧，好像从0.110.0起就改用hugo.toml。\n修改之后的hugo.toml尾部：\n[[menus.main]] url = \u0026#34;/categories\u0026#34; name = \u0026#34;分类 Categories\u0026#34; weight = 1 [[menus.main]] url = \u0026#34;/tags\u0026#34; name = \u0026#34;标签 Tags\u0026#34; weight = 2 [[menus.main]] url = \u0026#34;/posts\u0026#34; name = \u0026#34;归档 Archive\u0026#34; weight = 1 [[menus.main]] url = \u0026#34;/index.xml\u0026#34; name = \u0026#34;RSS\u0026#34; weight = 3 托管到Github pages 过程十分滴简单，先在GitHub新建一个仓库，名称一定要是你的用户名.github.io，比如我的就是hxxxer.github.io，记得选择公开和新建readme文档（为了在远程建立main分支）。\n然后在hugo项目根目录的pulic文件夹下新建仓库，连接远程仓库，拉取，添加，推送：\ngit init -b main git remote add origin-when-cross-origin xxx@github.com:xxx git pull --rebase origin main git add . git commit -m \u0026#34;\u0026#34; git push origin main 然后完了。以后就直接add commit push就行。\n参考 使用Hugo + blowfish搭建博客及Github Pages\n使用 Hugo + Github Pages 部署个人博客\npython使用自带的venv创建虚拟环境\n","permalink":"https://hxxxer.github.io/20241103/","tags":["Hugo","diary","blog"],"title":"初步使用Hugo以及主题的尝试"},{"categories":"课程学习","contents":"编辑于2024年11月1日\n前言sh 电脑系统为 win11 64位专业版，版本位21H2，版本号为22000.2538\n1. 开发板串口连接 1.1. 线材选择 需要两个线：\nusb转串口，串口要为公头的\n附带的串口母对母直连线（可以上网买，但是只能买直连的而不是交叉）。\n因为板子上面的串口是公头的，但是为母头线序，所以需要母对母直连线。注意买的usb转串口的两侧要匹配串口母对母直连线的螺丝或螺柱（螺丝对螺柱）。\n其实我感觉可以买一个usb转母头 + 公对母的交叉线，板子的母头线序交叉变成了公头线序，在加上母头线序的usb线，可能可以🤔。\n1.2. 连接测试 将上面的两组线组装并连接到板子和电脑上，板子拨到NorFlash启动，通电开机，打开SCRT，新建Serial连接（也可以使用minitools的串口工具），选择合适的COM号，可以去设备管理器查看。\n待成功连接，发一个数字或者按一下板子的复位按键，就可以看到功能菜单了。\nusb转串口线应该是不需要安装驱动的，网上好像也没有相关案例。\n2. 连接Usb下载线 2.1. 线材选择 直接用老师发的那根usb方口线就行，虽然我是自己买了一根。\n2.2. 驱动安装 2.2.1. 禁用驱动强制签名 这一步折磨了我相当久\n网上有些人直接运行FriendlyARM-2440-DVD\\windows平台工具\\usb下载驱动\\FriendlyARM USB Download Driver Setup_20090421.exe即可成功安装驱动，但是我不行，应该win10甚至win7之后都不行了。\n禁用驱动强制签名主要有三种：\n第一种方法： 设置-恢复-高级启动\n重启之后到高级选项，里面有一个启动设置，选择这个重启之后就可以选禁用驱动签名了\n但是这种方法我在最后一步缺失了“启动设置”选项，刘诚敏的可行\n这种方式最简单，而且禁用是只生效一次，再次重启失效，可惜我的不行。\n第二种方法： 去UEFI关闭安全启动，可以去高级启动里面进UEFI，也可以按F12（好像是这个键）\n开机后打开cmd/命令提示符，注意要以管理员运行，而且不能是PowerShell。运行指令\nbcdedit.exe /set {current} testsigning on 作用是进入测试模式。执行成功会提示“操作成功完成。”。\n重启电脑即可进入测试环境，桌面右下角可以看到测试模式。\n此时就可以随意安装驱动了，好像是驱动只要是有签名的就行，不安全的测试签名也可以。退出就on改off，要在安全启动关闭下运行。\n第三章方法： 也是关闭安全启动，去cmd（管理员）运行\nbcdedit /set {default} bootmenupolicy legacy 作用是启动高级启动设置，就是第一步那个。\n重启之后摁F8，就可以看到高级启动设置了，界面和win7的出问题之后的启动页面很像，按数字键选择就行。\n这个方法同样是只生效一次。\n2.2.2. 设备安装usb驱动 板子从NorFlash启动，通过usb方口线连接电脑后，可以在设备管理器看到有黄色感叹号。\n我在板子的usb连接上的情况下运行FriendlyARM-2440-DVD\\windows平台工具\\usb下载驱动\\FriendlyARM USB Download Driver Setup_20090421.exe，驱动能成功安装，但是电脑仍然不能正常识别设备。以下为手动安装驱动的步骤。\n找到驱动文件夹，我找到了3个\n安装minitools，位于FriendlyARM-2440-DVD\\windows平台工具\\MiniTools-USB下载工具\\MiniToolsSetup-Windows-20150528.exe，安装完成之后驱动文件会存在安装目录FriendlyARM\\MiniTools\\usb_dirver。\nsupervivi-usb-transfer-tool文件夹里面有一个Dirver文件夹。\n网上搜到一个自安装的驱动文件exe，可惜依然不能识别到。安装之后用dism++提取。\n右键设备，选择更新驱动程序。然后按照下面的图片操作。\n2.3. 连接测试 测试可以将位于FriendlyARM-2440-DVD\\images\\2440test\\的测试文件2440test_T35.bin烧到板子上运行。\n具体的烧录过程要去看2011-4-21版的Mini2440用户手册（可以去官网下载）。\n这里并不能使用minitools烧录，而且minitools也不能识别到设备，原因如下：根据在SCRT看到的功能菜单，说明板子的NorFlash烧录的是旧版的supervivi，而不是新版的superboot，所以不支持minitools。\n想烧superboot的可以参考这里，需要JTAG线 + JLINK + 转接板。\n参考 与Mini2440开发板有关的开发操作-CSDN\nAndroid fastboot驱动无法安装和识别问题-CSDN\n4 种简单方法，快速进入主板 BIOS 或 UEFI 固件设置\nWin11和Win10怎么禁用驱动程序强制签名? - 知乎评论区\n广州友善电子计算机科技有限公司\n","permalink":"https://hxxxer.github.io/20241101/","tags":["嵌入式","mini2440"],"title":"mini2440连接记录"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml ``` [outputs] home = [\u0026ldquo;HTML\u0026rdquo;, \u0026ldquo;JSON\u0026rdquo;] ```\nSearching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category ``` \u0026hellip; \u0026ldquo;contents\u0026rdquo;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026ldquo;tags\u0026rdquo;:{{ .Params.tags | jsonify }}{{end}}, \u0026ldquo;categories\u0026rdquo; : {{ .Params.categories | jsonify }}, \u0026hellip; ```\nEdit fuse.js options to Search static/js/search.js ``` keys: [ \u0026ldquo;title\u0026rdquo;, \u0026ldquo;contents\u0026rdquo;, \u0026ldquo;tags\u0026rdquo;, \u0026ldquo;categories\u0026rdquo; ] ```\n","permalink":"https://hxxxer.github.io/search/","tags":null,"title":"Search Results"}]